statment    : expr ((COMMA expr)* KEYWORD)? end

expression  : KEYWORD:var IDENTIFIER EQUALS expression
            : KEYWORD:write expression
            : arith_op
            : logic_op

logic_op    : comp_op (KEYWORD:and|KEYWORD:or comp_op)*
            : KEYWORD:not logic_op

comp_op     : arith_op (DOUBLE_EQUALS|NOT_EQUALS|GREATER|LOWER|GREATER_EQUALS|LOWER_EQUALS arith_op)*

arith_op    : term (PLUS|MINUS term)*

term        : factor (MULT|DIV factor)*

factor      : PLUS|MINUS value
            : LPAREN arith_op RPAREN
            : call
            : list_element
            : if_expr
            : list_expr
            : func_def
            : class_def

list_element: get_list_element
            : set_list_element
            : value

attribute   : IDENTIFIER DOT IDENTIFIER
            : value

value       : NUMBER|STRING|IDENTIFIER
            : KEYWORD:this

call        : IDENTIFIER (LPAREN (expr (COMMA expr)*)? RPAREN)?

get_list_element: IDENTIFIER LSQARE expr RSQARE
set_list_element: IDENTIFIER LSQARE expr RSQARE EQUALS expr

if_expr     : KEYWORD:if 
              logic_op COLON 
              statment
              (KEYWORD:else COLON 
              statment )?

list_expr   : LSQARE (expr (COMMA expr)*)? RSQARE

func_def    : KEYWORKD:function IDENTIFIER
              LPAREN (IDENTIFIER (COMMA IDENTIFIER)*)? RPAREN
              COLON statment

class_def   : KEYWORD:class IDENTIFIER COLON
            : statment


$var count = 0

trigger on <event>: <expr>

class Test: function Test(a, b): this.a = 10 end, function get_a(): this.a end end

function for(start, finish, body): if start < finish: body(), var start = start + 1, for(start, finish, body) end end
function calc(value_1, op, value_2): if op == "+": value_1 + value_2 else: if op == "-": value_1 - value_2 else: if op == "*": value_1 * value_2 else: if op == "/": value_1 / value_2

class foo:

    function foo():
        var a = "valueA",
        var b = "valueB"
    end,

    function test():
        write(a),
        write(b)
    end

end


# Possible Class type declaration
# Requires Object type, this|self keyword, period '.' tokentype

class Class(Callable):

    body_node = any
    arg_names = []

    def execute(self, args, context: Context):
        interpreter = Interpreter()

        self.check_args(args, self.arg_names)
        new_context = self.create_context(args, self.arg_names, context)

        interpreter.visit(self.body_node, new_context)

        constructor = new_context.symbol_table.get(self.name)
        call = CallNode(constructor, new_context)

        interpreter.visit(call, new_context)

        return Object(new_context)

class Object()
